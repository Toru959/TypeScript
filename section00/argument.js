"use strict";
'値渡しと参照渡し';
'値渡しは、変数が関数に渡すタイミングで変数が別の変数にコピーされます。もともと同じ変数でも、関数の呼び出し元と関数の内部処理では独立した値になります。';
'そんため、関数の処理で引数に値を代入しても、関数呼び出し元の変数に影響しません。';
// C言語
// #include <stdio.h>
// void ChannelMergerNode(int n){
//     n = 2;
// }
// int main(){
//     int a = 1;
//     Change(a);
//     pringf("%d", a); // 1
// }
'参照渡しは、関数呼び出し元の変数が関数の処理でも共有されます。もし、関数の処理で引数に当たりを代入すると、関数呼び出し元の変数も変化します。';
// C言語
// #include <stdio.h>
// void ChannelMergerNode(int *n){ // aのアドレスを引数として受け取る
//     *n = 2; // aのアドレスに2を代入する。
// }
// int main(){
//     int a = 1;
//     ChannelMergerNode(&a); // aのアドレス
//     printf("%d", a); // aの値が2になる。
// }
'JavaScriptでは関数の引数はすべて値渡しになる。';
'ところが、オブジェクトについては少し特殊です。オブジェクトはどこでも参照になります。オブジェクトに別の変数名をつけても、オブジェクトが複製されて新たなオブジェクトができるのではなく、';
'異なる変数名同士で一つのオブジェクトを指すということです';
// const x = { n: 1 }
// const y = x;
// y.n = 2;
// console.log(x); // { n: 2}
'ただし、yに別の値を代入した場合は、x, yは共通のオブジェクトを参照しなくなり、yへの変更はxには影響しなくなる。';
// const x = { n: 1 };
// let y = x;
// y = { n: 2 }; // yに別のオブジェクトを再代入
// y.n = 3;
// console.log(x); // { n: 1 }
// console.log(y); // { n: 3 }
'共有されたオブジェクトはプロパティを変更した場合、他の変数にもその変更が影響します。この仕様は引数にも同じことが言えます。';
// function change(y){
//     y.n = 2;
// }
// const x = { n: 1};
// change(x);
// console.log(x); // { n: 2 }
'引数の場合も、変数の再代入の使用と同様に、yに別の値を代入した場合は、x, yは同じオブhジェクトを参照しなくなるため、yへの影響はxに影響しなくなる。';
// function change(y){
//     y = { n: 2};
//     y.n = 3;
//     console.log(y) // { n: 3 }
// }
// const x = { n: 1 };
// change(x);
// console.log(x); // { n: 1 }
