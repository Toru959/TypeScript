'変数宣言:letとconst'
'JavaScriptの変数宣言(variable declaration)には、letとconstがあります。'

'letの変数宣言'
'letを用いた変数宣言の書き方は次のようになる'
let x = 1;

'再代入可能'
let x1 = 1;
x1 = 2; // 再代入可能

'letは変数の初期値なしで変数定義できます。初期値なしの変数の値はundefinedになります。'
let x2; //初期値なし
x2 = 1;

'constの変数宣言'
'constを用いた変数宣言の書き方は次の通り。初期値は必須'
const y = 2;

'constは変数への再代入が禁止されている'
const y2 = 1;
// y2 = 2;

'letとconstの使い分け'
'初めてJavaScriptを書く場合に、letとconstのどちらの変数宣言をすればいいか迷う。'
'基本はconstで変数宣言して必要な場合のみに、letを使うのがおすすめ。'

'constは可変オブジェクトを保護しない'
'constは再代入不可な変数名を宣言するだけです。constには、可変(エミュータブル)なオブジェクトのプロパティを不変にする保護効果はない。'
'たとえば、constでオブジェクトを宣言した場合、変数自体への再代入はいできない。ところが、オブジェクトプロパティは変更できる。'
const obj = { a: 1 };
obj = { a: 2 }; // 再代入は不可
obj.a = 2; //プロパティの変更はできる

'TypeScriptでオブジェクトを不変にするには、プロパティを読み取り専用にする必要があります。'
'配列もオブジェクトの一種なので同様です。変数自体の再代入はできません。しかし、配列要素は変更できます。'
const arr = [1, 2];
arr = [3, 4]; //再代入は不可
arr.push(3); // 要素の変更はできる

'変数宣言の型注釈'
'TypeScriptでは変数宣言をするときに、その変数にどんな値が代入可能かを指定できます。その指定のことを型注釈といいます。'
'変数宣言の型注釈は、変数の右に型を書きます'
// const num: number = 123;

'変数宣言の型推論'
'TypeScriptには型推論と呼ばれる機能があります。型推論は、コンパイラが型を自動で判別する機能です。'
'プログラマーは型推論を活用すると、型注釈を省略できるので、コードの記述量を減らせる利点があります。'
let x3 = 1; //let x3: numnber = 1;と同じ意味になる
x3 = "hello";

'上の例では変数にx3に1の値コードを代入しています。この時点でコンパイラは代入された値から、変数x3の型をnumber型と自動で判別します。型注釈x3: numberを書くことを省略できる。'
'型注釈が書かれていないもののx3はnumber型を推論されているため、x3にhelloのstring型を再代入する記述は、型の不一致によりコンパイルエラーとなります。'

'型推論と動的型付けの違い'
'型を書かないという意味では、JavaScriptをはじめRubyやPHPなどの動的型付け言語でも同様です。'
'型推論はコンパイルのタイミングで型が決定され、その方が変更されることはありません。型をプログラマが書くかコンパイラが自動で決めるという点で違いがあり、あくまで政敵付の世界に閉じた話になります。'
let x4 = 1;
x4 = "hello";
console.log(x.substring(1, 3));
// エラー

'一方、動的型付けでは実行時に型が決まるので、実行タイミングにより型が変化します。'
let x5 = 1;
x5 = "hello";
console.log(x.substring(1, 3));
// el